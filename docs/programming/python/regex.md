---
title: python 正则表达式
date: 2018-11-14 20:31:34
categories: python
tags: [python, regex, 正则表达式]

---

市面上几乎所有讲正则表达式的书都不是专门用 python 讲的, 最多用一两章内容介绍一下 python 正则表达式的用法. 一般的正则表达式理论或者各个流派之间的差异对于data science 时代只用 python 的人来说完全没有必要了解.  本文专门针对 python 讲解正则表达式, 从实践到理论全贯通, 主要参考 Jeffrey Friedl 的<精通正则表达式> 和 <正则指引>

<!-- more -->

正则表达式, 学习曲线虽然陡峭, 但是一旦学会, 非常有用, 能极大提高效率. 

# 流派

首先, python 属于传统型 NFA, 之所以说"传统型", 是因为, 为了符合 POSIX 标准, 后来通过修改, 得到了新型的 NFA. 后面所说的 NFA 一律指传统型 NFA.  NFA 可以理解为表达式主导. 与 NFA 相对的是另外一种 DFA. NFA与 DFA 的差别, 不需要太多了解. 但是我们必须要了解传统型 NFA匹配的过程, 这是因为: 如同 C++ 中的逻辑运算一样, 匹配的过程是短路的, 也就是说一旦匹配成功, 就不再继续匹配了,  这样的话, 如果有多个解的话, 返回的不一定是你想要的那一种. 所以我们务必弄清楚匹配的过程. 不过我们并不需要彻底弄清楚具体的匹配过程, 只需要总结出若干原则, 帮助我们判断如果匹配成功, 得到的到底是哪个解. 

### 传统型 NFA的原则 (功力尚浅, 参考<精通正则表达式>)

表达式主导

最左最长

### 编码

编码问题本身就比较复杂, 加上 python2 和python3 的编码方式又有所区别, 本文只讨论 python 3. 

先理清下常见的编码方式, ASCII ,GBK, Unicode 编码.

ASCII码用 1 个字节也就是 128 种可能, 这足以表示英文字母、半角数字、半角标点、半角空格等不可见符号. Unicode编码包含了几乎所有语言的字符. 常见的 utf-8, utf-16都是 unicode 的一种存储格式.   Python3 中默认的字符串编码就是 unicode. 



### 转义

一个正则表达式需要经过两次转义, 先后是字符串转义和正则转义. 举例

为了匹配 6位数字, 我们需要的正则表达式是 `\d{6}`, 这里之所以需要 '\', 就是因为对 'd' 进行转义, 使其具有特殊意义. 但在 python 中, 我们不能直接写 '\d{6}'. 因为这是一个字符串, 对于字符串来说, '\' 具有特殊意义, 要想得到一个 '\\', 需要再加一个'\\', 也就是 '\\\\d{6}'



Python3 引入了原生字符串的概念, `r'str'` 代表的就是 str 本身, python 不再进行字符串转义.  所以上面的例子在 python3 中可以直接写成 `r'\d{6}'` . 







# Python 正则表达式理论

### 模式

##### 单行模式与多行模式

其实单行模式与多行模式没有任何关系. 如果你不指定的话, 会采用默认模式. 

单行模式改变的是 '.' 的匹配, 默认模式下, '.' 能匹配除换行符以外的所有字符, 单行模式下, '.' 能匹配一切字符.  多行模式改变的 '^' 与 '\$'  . 默认模式下, '^' 和 '\$' 只能匹配整个字符串的开头和结尾, 不管中间有没有换行符, 可以理解为 "单行模式" . 多行模式下, '^' 和 '\$' 能真真匹配每一行. 

#####  ASCII 与 unicode 模式

此外, 正则表达式的匹配模式也有 ASCII 与 unicode 模式之分. 这主要是 `\w`  `\d`  `\s` 所能代表的字符的区别.  python3 默认 unicode 模式, 可以用 (?a) 显式指定 ASCII 模式. 

ASCII模式下 \w 能代表 ASCII 编码中的单词字符, 也就是英文字母、半角数字、下划线. 类似地, \d 能代表半角数字. \s 能代表半角空格等不可见字符. 

 unicode 模式下 \w 能代表 unicode 编码中的单词字符, 包括英文字母、中文、全半角数字、下划线. \d 能代表全半角数字 . \s能匹配任意空白不可见符号. 

##### 模式指定与作用范围 

模式指定有两种方式, 一种是在正则表达式中, 通过模式修饰符(如?m)来指定, 多个模式修饰符可以连写, 如 (?mi). 另一种是通过预定义的常量(如 re.S) 来指定, 多个预定义的常量可以通过 '|' 相连, 如 re.M|re.I . 前一种方法可以通过括号指定范围, 但是后一种范围只能是整个正则表达式.   注意到, 模式修饰符都是小写, 预定义的常量都是大写. 

### 锚点

##### 单词边界 \b

\b 代表这个位置两侧中, 一侧有 \w 字符, 一侧没有. 由于 \w 在不同匹配模式下, 所能匹配的字符不同, 所以 \b 在不同模式(指 ASCII 与 Unicode) 下意义也不一样. 

##### 行边界

默认模式下, '^' 和 '\$' 只能匹配整个字符串的开头和结尾, 不管中间有没有换行符, 可以理解为 "单行模式" . 多行模式下, '^' 和 '\$' 能真真匹配每一行. 

但是有时候, 我们同时需要这两种功能. 这时可以使有 '\A' 和 '\Z' , 不管在哪种模式下, 它们都匹配整个字符串的开头和结尾. 

##### 环视

环视分为肯定和否定(否定只需要将 '=' 改成 '!' 即可), 又有左右顺序之分, 所以总共有 4 种. 环视有两种功能, 一种是作为锚点, 像单词边界一样, 确定位置. 另一种是, 用来排除. 

Python 否定环视时, 长度必须确定, 也就是说, 不仅不能用量词, 如果用到多选结构, 各选项之间长度也必须相等. 

###### 作为锚点

一个例子就可以说清, 比如我想把 wanglpsite 换成 wanglp'site

只需要 `re.sub(r'(?<=wanglp)(?=site)',"'",'wanglpsite')`. 分别匹配的是 'wanglp' 右边, 'site' 左边的那个位置. 



###### 用来排除

比如 '(?!3)\d' 就能匹配 除 3 以外的 0-9. 

 再看一个例子, 要想匹配 `<p>Billions <p> and Billions </p>` 中的 `<p> and Billions </p>` 

`<p>.*?</p>` 不行,  因为会匹配到 `<p>Billions <p> and Billions </p>` 

```python 
In [39]: str = '<p>Billions <p> and Billions </p>'

In [40]: pattern = r'<p>(?:(?!<p>).)*?</p>'

In [41]: r = re.search(pattern, str)

In [42]: r.group()
Out[42]: '<p> and Billions </p>'
```



### 捕获分组与引用

凡是 ( ) 包裹的都是分组, 凡是分组如果没有 (?: ) 都是捕获分组,捕获分组从左到右依次编号为1, 2, ...     

在 python 中捕获分组主要有三种用途, 第一种是为了在最后想要获得分组匹配的结果, 第二种是反向引用, 第三种是用于 re.sub. python 支持同时使用命名分组和数字分组, 但为了格式的统一, 最好只用一种. 为了比较两种方式的具体使用, 后文对两种方式都进行了展示. 

- 用途一

```python
In [2]: s = re.search(r'(?P<year>\d{4})-(?P<month>\d{2})-(\d{2})','2018-11-12')

In [3]: s.groups() # 返回(group(1), group(2),..)
Out[3]: ('2018', '11', '12')

In [4]: s.group()
Out[4]: '2018-11-12'

In [5]: s.group('month')
Out[5]: '11'

In [6]: s.group(0) # 同时支持命名分组和数字分组
Out[6]: '2018-11-12'

In [7]: s.group(2)
Out[7]: '11'

```





- 用途二: 反向引用 


```python 
In [48]: s = re.search(r'(?P<year>\d{4})-(?P<month>\d{2})-(\2)','2018-11-12 2018-11-11')

In [49]: s.groups()
Out[49]: ('2018', '11', '11')

In [50]: s = re.search(r'(?P<year>\d{4})-(?P<month>\d{2})-(?P=month)','2018-11-12 2018-11-11')

In [51]: s.groups()
Out[51]: ('2018', '11') # 注意, 利用?P=month反向引用的分组没有被捕获
    
In [68]: s.start(2)
Out[68]: 16
    
In [8]: s = re.search(r'(\d{4})-(\d{2})-(\2)','2018-11-12 2018-11-11')  # 综合来看, 这种方法最好

In [9]: s.groups()
Out[9]: ('2018', '11', '11')
    


```

- 用途三:re.sub


```python
In [55]: re.sub(r'(?P<year>\d{4})-(?P<month>\d{2})-(\d{2})',r'\1-\3-\2','2018-11-12')
Out[55]: '2018-12-11'

In [56]: re.sub(r'(?P<year>\d{4})-(?P<month>\d{2})-(\d{2})',r'\g<year>-\3-\g<month>','2018-11-12')
Out[56]: '2018-12-11'
```





从上面三组例子可以看出, 两种方式完全可以混用, 只是反向引用时捕获有点问题, 所以, 最好的方法是全用数字. 





### python re api

python 中使用正则表达式有两种方式, 一种是函数式, 一种是面向对象式.  函数式就是直接调用 re 中提供的 search, findall 等函数, 面向对象式就是将正则表达式 先 compile 成一个对象, 然后, 将这个对象传给 search, findall 等函数. 如果需要多次匹配, 则后一种效率更高. 



##### re.search

re.search 如果能匹配, 返回一个 MatchObject, 否则返回 None.  假设 result 是一个 MatchObject. 

##### re.match

re.match 是特殊的 search,  re.match(r'regex', str) 相当于 re. search(r'\Aregex', str). 

##### re.findall 

re.findall 会返回一个不相交的匹配结果的 list. 这里有两点需要注意. 第一, **不相交**, 这说明, re.findall 并不是真的 find all, 例如

```python 

In [13]: re.findall(r'121', '12121')
Out[13]: ['121']


```



第二, 对于匹配结果的理解. 如果正则表达式中有捕获分组, 则匹配结果是一个由捕获内容组成的元组,也就是 (group(1), group(2),...).  如果正则表达式中没有捕获分组, 则匹配结果就是整个匹配到的内容, 也就是 group(0), 但事实上, 这时候你无法知道完整匹配, 不过可以在整个正则表达式外面加一个 ( ).



##### re.finditer

 返回迭代器, 避免匹结果过多, 一次性匹配耗时太长. 



### re.sub 

前文已展示过用法 

<hr>王礼萍  原创<br>

 更多内容请访问 https://wanglp.site 









