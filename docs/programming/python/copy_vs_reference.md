作为从 C++ 转到 python 的码农, 对于复制, 引用, 内存回收等问题, 总是很担心, 今天就来好好研究一下, 这是解决很多 bug 的关键,当然最好能做到防患于未然.





## 变量与对象

对象就是内存中的数据, 变量是指向对象的一个标签, 变量不是盒子.

```
a = 2
id(a) == id(2) #True
a is 2 # True
```

2 就是对象, a 是变量. 变量具有 id, 值, 变量的 id, 和其指向的对象 id 相同.

`is` 用来判断 id 是否相同, `==` 判断值是否相同

## 可变对象与不可变对象

可变对象, 是指所指内存可以就地改变, 改变对象后, id 不变. 不可变对象是指所指内存不可以就地改变, 改变对象时, id 会变化, 相当于在一个新的内存重新初始化一个对象.

```
>>> a = 2
>>> id(a)
140720338915408
>>> a = 3
>>> id(a)
140720338915384
```

不可变对象有:

- 2, 3.5 等数
- 字符串

可变对象有:

- list
- set
- 字典

还有一类相对不可变, 也就是本身不可变, 但其保存的是对象的引用, 引用的对象可以改变, 比如元组

```
>>> a = (1,2, [3,4])
>>> id(a)
4556270320
>>> a[-1].append(5)
>>> id(a)
4556270320
```

## 浅拷贝与深拷贝

对于不可变对象, 不用担心这个问题, 因为, 假如多个变量指向同一个对象, 如果其中一个变量发生变化, 它并不会改变多个变量所指的公共内存, 而是去开辟一片新的内存. 所以我们只需要考虑可变对象和相对不可变对象.

在 python 中, 拷贝有三种方法:

- 调用对象的构造函数 (浅拷贝)
- 调用 copy.copy (浅拷贝)
- 调用 copy.deepcopy (深拷贝)

浅拷贝就是只复制了最外层容器, 副本中的元素是源容器中元素的引用. 如果容器中元素都是不可变的, 那没关系, 但是如果有可变的,那就会造成问题.

## 函数传参

python 中函数传参是通过 call by sharing, 和 c++ 中引用传参不完全一样. 对于不可变元素, 不会改变传入的参数, 但是对于可变元素, 可能会改变传入的参数.

```
>>> def fun(a,b):
...     a+=b
...     return a


>>> a = 1
>>> b = 2
>>> fun(a,b)
3
>>> (a,b)
(1, 2) # 没有改变不可变对象 a

>>> a = [1,2]
>>> b = [3]
>>> fun(a,b)
[1, 2, 3]
>>> a
[1, 2, 3] # 改变了可变对象 a
```

## 不要用可变对象作为参数默认值

```
>>> class bus(object):
...     def __init__(self, passengers=[]):
...             self.passengers = passengers
...     def pick(self, name):
...             self.passengers.append(name)
...     def drop(self, name):
...             self.passengers.remove(name)
... 
>>> 
>>> bus1 = bus()
>>> bus1.pick('Zhao')
>>> print(bus1.passengers)
['Zhao']
>>> bus2 = bus()
>>> print(bus2.passengers)
['Zhao'] # 和我们想像的不一样
```

因为参数 passengers 的默认值空列表在 `bus1.pick('Zhao')` 之后, 不再为空, bus2 初始化时, 用的就是这个不为空的列表初始化